<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Icarus 技术文档</title>
    <meta name="description" content="Icarus Technical Blog">
    <meta name="generator" content="VitePress v1.4.5">
    <link rel="preload stylesheet" href="/kaka-blog-github/assets/style.C2ccTkHG.css" as="style">
    
    <script type="module" src="/kaka-blog-github/assets/app.BoxL3HgH.js"></script>
    <link rel="preload" href="/kaka-blog-github/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/kaka-blog-github/assets/chunks/theme.BUBI2oWt.js">
    <link rel="modulepreload" href="/kaka-blog-github/assets/chunks/framework.DL0M-SdH.js">
    <link rel="modulepreload" href="/kaka-blog-github/assets/notes_闭包：从编译原理的角度理解作用域.md.C2ewL7at.lean.js">
    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/kaka-blog-github/" data-v-1168a8e4><!--[--><!--]--><!--[--><img class="VPImage logo" src="../logo.png" alt data-v-8426fc1a><!--]--><span data-v-1168a8e4>浩瀚宇宙，未知征程</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>Web前端开发</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/kaka-blog-github/notes/WebSocket%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6.html" data-v-35975db6><!--[--><span data-v-35975db6>前端应用笔记</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/kaka-blog-github/three/01.Three.js%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html" data-v-35975db6><!--[--><span data-v-35975db6>Three.js的3D世界</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/kaka-blog-github/LeetCode/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.html" data-v-35975db6><!--[--><span data-v-35975db6>LeetCode 算法题解</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/kaka-blog-github/viewpoint/%E5%A4%A7%E5%8E%82%E7%9A%84%E5%91%98%E5%B7%A5%E8%BF%98%E6%98%AF%E5%BA%94%E8%AF%A5%E6%9C%89%E5%8D%B1%E6%9C%BA%E6%84%9F.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>一些值得记录的观点</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>前端笔记</h2><!----></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/WebSocket%E5%BF%83%E8%B7%B3%E9%87%8D%E8%BF%9E%E6%9C%BA%E5%88%B6.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>1.WebSocket 心跳重连机制</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>2.函数节流与函数防抖</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/%E7%94%A8Performance%E5%92%8CMemory%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>3.用 Performance 和 Memory 监控内存泄露</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/JavaScript%E4%B8%AD%E7%9A%84this%E7%9A%84%E5%8E%9F%E7%90%86.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>4.JavaScript中的this的原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/AsyncAwait%20%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>5.Async/Await如何通过同步的方式实现异步</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B8%8E%E4%B8%96%E7%95%8C%E8%A7%82.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>6.知识体系与世界观</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/kaka-blog-github/notes/%E9%97%AD%E5%8C%85%EF%BC%9A%E4%BB%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>7.闭包：从编译原理理解作用域</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _kaka-blog-github_notes_%E9%97%AD%E5%8C%85%EF%BC%9A%E4%BB%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F" data-v-39a288b8><div><h3 id="面试官视角的-闭包" tabindex="-1"><!----> <a class="header-anchor" href="#面试官视角的-闭包" aria-label="Permalink to &quot;&lt;font style=&quot;line-height:1.6;font-size:24px;&quot;&gt;面试官视角的“闭包”&lt;/font&gt;&quot;">​</a></h3><p>闭包问题不好答，原因往往不在于闭包本身有多么晦涩神秘，而在于闭包的背后有太多太多的故事可以深挖。面试经历稍微丰富一些的同学会发现，大多数面试场景下，面试官不会直接问你“闭包是什么”，而是会直接甩出来一套代码片段给你，问“这段代码的运行结果是什么？”。遇到这种情况，大家真要在心里松一口气了，毕竟直接脑内跑代码。是闭包最温和、痛苦程度最小的一种考察方式。针对这种考察方式，我们本节也会有习题给到大家来做。但除此之外，我希望大家能对另一种提问方式引起注意 ——“你如何理解 JavaScript 中的闭包” ？</p><p>这个问题的区分度非常高。它的特点就是人人都能答上那么一两句，但只有很少的人可以答好。而且它往往不作为一个孤立的问题出现，而是作为一些更加深入的问题的“引子”。</p><p>当面试官问你“如何理解”的时候，他大概率并不是想听你背诵“闭包是一种 ####### 的函数”，而是想跟你聊聊作用域、作用域链等触及 JS 语言核心的一些知识点，聪明的面试官，还会借机引出变量提升、暂时性死区、执行上下文等附加话题，甚至想问问你 JS 中的不同异常之间本质的区别在哪里？词法作用域模型又是啥？</p><p>所以说，想答好闭包问题，能看懂闭包代码只是登堂入室的第一步。问题的关键，在于闭包背后的这些故事。接下来，我们就抽丝剥茧，一点一点把这些看似高深的问题肢解掉，帮助各位从根儿上掌握闭包所牵扯出来的这一整块的知识脉络。</p><h3 id="理解作用域的实现机制" tabindex="-1">理解作用域的实现机制 <a class="header-anchor" href="#理解作用域的实现机制" aria-label="Permalink to &quot;理解作用域的实现机制&quot;">​</a></h3><p>大家知道，几乎每一种编程语言，它最基本的能力都是能够存储变量当中的值、并且允许我们对这个变量的值进行访问和修改。那么有了变量之后，应该把它放在那里、程序如何找到它们？这是不是需要我们提前约定好一套存储变量、访问变量的规则？这套规则，就是我们常说的作用域。更多时候，我们提到作用域的时候，指的是这个规则约束下的一个变量、函数、标识符可以被访问的区域（这时它就更具体了）。 要想理解作用域的实现机制，我们需要结合 JS 的编译原理一起来看（别跑，这块不难）。 我们来看一个简单的声明语句：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>大家觉得 JS 会怎么理解这句 “话” 呢？</p><p>在我们看来，这只是一个声明语句。但是在 JS 引擎眼里，它却包含了两个声明：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译时处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ‘xiuyan’ </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 运行时处理</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>何为编译时、何为运行时？难道 JS 不是不存在编译阶段的 “动态语言” 吗？ 事实上，JS 也是有编译阶段的，它和传统语言的区别在于，JS 不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。回到我们这个语句上来，我们来看看编译阶段和执行阶段阶段都发生了什么事情：</p><ul><li>编译阶段： 这时登场的是一个叫 编译器 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段</li><li>执行阶段： 这时登场的就是大家常常听到的 JS 引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。</li></ul><p>这里出现了一个有趣的东西，就是我们引擎的查找过程 —— 何谓探出头去？何谓 “外面” 呢？这就引出了我们 JS 作用域里一个非常重要的概念 —— 作用域链。</p><h3 id="作用域套作用域-就有了作用域链" tabindex="-1">作用域套作用域，就有了作用域链 <a class="header-anchor" href="#作用域套作用域-就有了作用域链" aria-label="Permalink to &quot;作用域套作用域，就有了作用域链&quot;">​</a></h3><p>现在我们已经知道，作用域本质上就是程序存储和访问变量的规则。上个小节，我们聊过了作用域在 JS 这门语言中的实现机制。现在，我们来看看，这套规则的内容具体是怎么回事儿。 在 JS 世界中，目前已经有了三种作用域：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块作用域</li></ul><p>我们先来通过例子唤醒一下大家大脑里关于这三种作用域的记忆： <strong>全局作用域</strong> 声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量拥有全局作用域：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局作用域内的变量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数作用域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 块作用域</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;BigBear&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;BigBear&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面这个例子我们可以看出，全局变量在全局作用域、函数作用域和块作用域里都可以获取到～</p><p><strong>函数作用域</strong></p><p>在函数内部定义的变量，拥有函数作用域。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// name 是全局变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">myName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// myName 是传入 showName 的局部变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myName);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// hello 被定义成局部作用域变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> helloString </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello everyone&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloString);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;xiuyan&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;hello everyone&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myName); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出错误：myName 在全局作用域未定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloString); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出错误：hello 在全局作用域未定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloString, myName); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在这个例子里，myName 和 hello 都是在函数内部定义的变量，它们就被“画地为牢” ，作用域仅局限于函数内部。全局作用域和块作用域里都访问不到它们。</p><p><strong>块作用域</strong></p><p>ES6 开始，我们迎来了了两个用于声明变量的新关键词: <code>let </code>和 <code>const</code>。这两个关键字定义的变量，如果被一个大括号 { } 这样括住了，那么这个大括号就是一个代码块，大括号括住的这些变量就形成了一个块作用域：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	console</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个例子里我们可以看出，块作用域内的变量只要出了自己被定义的那个代码块，那么就无法访问了。这点和函数作用域比较相似 —— 它们都只在“自己的地盘”上生效，所以它们也统称为“局部作用域 ”。</p><p><strong>作用域链</strong></p><p>OK，现在我们完成了作用域类型的面面观，话题回到作用域链上。在我们实际开发中，通常不止用到一种作用域。当一个块或者一个函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。比如这样：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们试图在 addA 这个函数里访问变量 b 的时候，考虑到函数作用域内并没有对 b、c 这两个变量作定义，所以一开始肯定是找不到的。要想找到 b、c ，该怎么做？就是我们上文提到的“探出头去”，对吧？探出头去，去上层作用域（全局作用域找），找到了 b ，那么就可以直接拿来用了；没找到 c，并且全局作用域已经没有上层作用域了（头探不出去了），那就歇菜，报错！这就是上文“执行阶段 ”里我们描述的那个过程。</p><p>在这个查找过程中，层层递进的作用域，就形成了一条作用域链。</p><h3 id="理解闭包" tabindex="-1">理解闭包 <a class="header-anchor" href="#理解闭包" aria-label="Permalink to &quot;理解闭包&quot;">​</a></h3><p>我们再来看一个例子：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addABC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> add;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalAdd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addABC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">globalAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这个例子里，其中 add 这个函数，它嵌套在函数 addABC 的内部，想要查找 a、b、c 三个变量，它得去上层的 addABC 作用域里找，对吧？像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。</p><p>对于闭包，大家如果能理解到这个程度，面试时已经不会在这上面吃亏了。可以说上面这个版本的闭包定义，大家面试的时候答出来，就是 100 分。但是如果你想要进大厂、想要进好团队，那么 100 分可能还不太够，需要 120 分。120 的答案，我们会在下一节用整整一节的时间给大家展开讲。</p><h3 id="加餐-lhs、rhs——-面试官到底在问啥" tabindex="-1">加餐：LHS、RHS—— 面试官到底在问啥？ <a class="header-anchor" href="#加餐-lhs、rhs——-面试官到底在问啥" aria-label="Permalink to &quot;加餐：LHS、RHS—— 面试官到底在问啥？&quot;">​</a></h3><p>在面试过程中，一些对技术深度期望比较高的面试官，为了试大家的“底细”，可能会在作用域、变量访问相关问题上冷不丁抛出 LHS、 RHS 这样听上去比较“高深”的名词。为了避免大家吃亏，我们这里把这俩哥拉出来遛遛： LHS、RHS，是引擎在执行代码的时候，查询变量的两种方式。其中的 L、R，分别意味着 Left、Right。这个“左”和“右”，是相对于赋值操作来说的。当变量出现在赋值操作的左侧时，执行的就是 LHS 操作，右侧则执行 RHS 操作：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xiuyan&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这个例子里，name 变量出现在赋值操作的左侧，它就属于 LHS。LHS 意味着 变量赋值或写入内存，</p><p>它强调的是一个写入的动作，所以 LHS 查询查的是这个变量的“家”（对应的内存空间）在哪。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个例子里，第一行有赋值操作，但是 name 在操作的右侧，所以是 RHS；第二行没有赋值操作，name 就可以理解为没有出现在赋值操作的左侧，这种情况下我们也认为 name 的查询是 RHS。RHS 意味着 变量查找或从内存中读取，它强调的是读这个动作，查询的是变量的内容。</p><p>对于 LHS、RHS 这两个概念，大家若能理解上面两个示例，能说出它们各自是怎么回事儿，就非常足够了。接下来，我们就进入词法作用域环节的学习。</p><h3 id="✅-专栏外补充内容" tabindex="-1">✅ 专栏外补充内容 <a class="header-anchor" href="#✅-专栏外补充内容" aria-label="Permalink to &quot;✅ 专栏外补充内容&quot;">​</a></h3><p>闭包就是能够读取其他函数内部变量的函数。 例如在 javascript 中，只有函数内部的子函数才能读取局部变量 ，所以闭包可以理解成“定义在一个函数内部的函数“。 在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 [1] 闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何 全局 上下文中定义的，而是在定义代码块的环境中定义（ 局部变量 ）。 “闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（ 作用域 ）。</p><h3 id="chatgpt写一篇关于javascript中闭包的文章-重点介绍闭包的使用场景和负面作用-并说明应该如何正确使用闭包" tabindex="-1"><code>ChatGPT</code>写一篇关于<code>JavaScript</code>中闭包的文章，重点介绍闭包的使用场景和负面作用，并说明应该如何正确使用闭包 <a class="header-anchor" href="#chatgpt写一篇关于javascript中闭包的文章-重点介绍闭包的使用场景和负面作用-并说明应该如何正确使用闭包" aria-label="Permalink to &quot;`ChatGPT`写一篇关于`JavaScript`中闭包的文章，重点介绍闭包的使用场景和负面作用，并说明应该如何正确使用闭包&quot;">​</a></h3><p><code>JavaScript</code>中的闭包是一种特殊的函数，它可以访问其他函数的作用域内的变量，即使该函数已经返回。在<code>JavaScript</code>中，所有函数都是闭包，因此它们都可以访问其他函数内的变量。</p><h5 id="闭包的使用场景" tabindex="-1">闭包的使用场景 <a class="header-anchor" href="#闭包的使用场景" aria-label="Permalink to &quot;闭包的使用场景&quot;">​</a></h5><ul><li>封装变量：闭包可以帮助我们隐藏程序内部的细节，保护变量不被外界误用或更改。</li><li>模拟私有变量：通过闭包，我们可以创建私有变量，避免在全局范围内污染命名空间。</li><li>实现面向对象编程：通过闭包，我们可以模拟类的实现方式，并实现继承，封装等特性。</li></ul><h5 id="闭包的负面作用" tabindex="-1">闭包的负面作用 <a class="header-anchor" href="#闭包的负面作用" aria-label="Permalink to &quot;闭包的负面作用&quot;">​</a></h5><ul><li>内存泄漏：闭包会保留它访问的所有变量，如果我们不正确的使用闭包，它们就可能成为内存泄漏的源头。</li><li>增加代码复杂度：因为闭包可以访问其他函数的作用域，如果不恰当的使用，可能导致代码变得难以理解和维护。</li></ul><h5 id="如何正确使用闭包" tabindex="-1">如何正确使用闭包 <a class="header-anchor" href="#如何正确使用闭包" aria-label="Permalink to &quot;如何正确使用闭包&quot;">​</a></h5><ul><li>明确需求：闭包应该被用于解决特定的问题，而不是作为一种代码编写的习惯。</li><li>避免内存泄漏：尽量在使用闭包时限制它访问的变量数量，并在不再使用闭包时立即释放它所占用的内存。</li><li>使用较少的闭包：尽量使用较少的闭包来解决问题，避免代码变得过于复杂。</li><li>注意闭包作用域：明确闭包的作用域，避免在不需要的时候保留变量。</li><li>注释代码：为了便于他人理解代码，在使用闭包时应该加以详细的注释。</li></ul><p>总之，闭包是一个强大的工具，但它也可能导致代码难以理解和维护。因此，在使用闭包时要谨慎，并遵循上述正确使用闭包的原则。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><!----><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-e98dd255>Last updated: <time datetime="2024-11-07T09:14:57.000Z" data-v-e98dd255></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/kaka-blog-github/notes/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B8%8E%E4%B8%96%E7%95%8C%E8%A7%82.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>6.知识体系与世界观</span><!--]--></a></div><div class="pager" data-v-e257564d><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><!----><p class="copyright" data-v-e315a0ad>Copyright © 2024-present Icarus</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"z-i7J8D8\",\"javascript_深入理解ecmascript中的_map_和_set_集合类型.md\":\"IYXbxK_m\",\"javascript_设计灵活和高效的前端数据管理工具类.md\":\"DO_9HL8K\",\"leetcode_no.1 两数之和.md\":\"19u9A4F5\",\"leetcode_no.11 盛最多水的容器.md\":\"DlxdFC8q\",\"leetcode_no.283 移动零.md\":\"DNI6R8cB\",\"leetcode_算法笔记.md\":\"CHOC6fOf\",\"notes_asyncawait 如何通过同步的方式实现异步.md\":\"CuVMrhTQ\",\"notes_javascript中的this的原理.md\":\"CbeL_gIu\",\"notes_vue3.x实现常见的三种文件类型在线预览.md\":\"CPsDcY0r\",\"notes_websocket心跳重连机制.md\":\"TaU2h-v3\",\"notes_函数节流与函数防抖.md\":\"CEkmZmlK\",\"notes_用performance和memory监控内存泄露.md\":\"s1oKJlTf\",\"notes_知识体系与世界观.md\":\"Dj9yQlLL\",\"notes_聊一聊javascript的proxy和object.defineproperty().md\":\"vi8Oz1q2\",\"notes_闭包：从编译原理的角度理解作用域.md\":\"C2ewL7at\",\"other_sealthecity.md\":\"DtAUh7Ni\",\"other_twitter.md\":\"D2CqegCH\",\"three_01.three.js基础概念.md\":\"Cil0dW7G\",\"three_02.gltf 模型格式.md\":\"DRp9zaO5\",\"three_03.加载gltf模型及材质，绘制模型线条.md\":\"u2kYnF4l\",\"three_附01.调试开发小工具.md\":\"vxBRdQfa\",\"viewpoint_大厂的员工还是应该有危机感.md\":\"CeK7bgEm\",\"viewpoint_对于2025年中国经济的一点思考.md\":\"CWO1nIrE\",\"viewpoint_对教育的看法.md\":\"BfzAn0LX\",\"viewpoint_有些人就像 chatgpt.md\":\"BiwDjQn8\",\"viewpoint_未来如何记住我们的过去？.md\":\"Rd3l4YkD\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Icarus 技术文档\",\"description\":\"Icarus Technical Blog\",\"base\":\"/kaka-blog-github/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"../logo.png\",\"siteTitle\":\"浩瀚宇宙，未知征程\",\"sidebar\":{\"/guide/\":[{\"text\":\"前端面试指南\",\"items\":[{\"text\":\"开篇：知识体系与面试世界观\",\"link\":\"/guide/知识体系与面试世界观\"},{\"text\":\"闭包：从编译原理理解作用域\",\"link\":\"/guide/闭包：从编译原理的角度理解作用域\"}]}],\"/notes/\":[{\"text\":\"前端笔记\",\"items\":[{\"text\":\"1.WebSocket 心跳重连机制\",\"link\":\"/notes/WebSocket心跳重连机制\"},{\"text\":\"2.函数节流与函数防抖\",\"link\":\"/notes/函数节流与函数防抖\"},{\"text\":\"3.用 Performance 和 Memory 监控内存泄露\",\"link\":\"/notes/用Performance和Memory监控内存泄露\"},{\"text\":\"4.JavaScript中的this的原理\",\"link\":\"/notes/JavaScript中的this的原理\"},{\"text\":\"5.Async/Await如何通过同步的方式实现异步\",\"link\":\"/notes/AsyncAwait 如何通过同步的方式实现异步\"},{\"text\":\"6.知识体系与世界观\",\"link\":\"/notes/知识体系与世界观\"},{\"text\":\"7.闭包：从编译原理理解作用域\",\"link\":\"/notes/闭包：从编译原理的角度理解作用域\"}]}],\"/BlockChain/\":[{\"text\":\"《区块链技术与应用》公开课\",\"items\":[{\"text\":\"比特币的密码学原理\",\"link\":\"/BlockChain/比特币的密码学原理\"},{\"text\":\"比特币的数据结构\",\"link\":\"/BlockChain/比特币的数据结构\"}]}],\"/flutter/\":[{\"text\":\"Flutter\",\"items\":[{\"text\":\"Dart 语法\",\"link\":\"/flutter/dart\"},{\"text\":\"Flutter 基础\",\"link\":\"/flutter/flutter\"}]}],\"/three/\":[{\"text\":\"Three.js的3D世界\",\"items\":[{\"text\":\"01.Three.js基础概念\",\"link\":\"/three/01.Three.js基础概念\"},{\"text\":\"02.glTF 模型格式\",\"link\":\"/three/02.glTF 模型格式\"},{\"text\":\"03.加载GLTF模型及材质，绘制模型线条\",\"link\":\"/three/03.加载GLTF模型及材质，绘制模型线条\"},{\"text\":\"附01.调试开发小工具\",\"link\":\"/three/附01.调试开发小工具\"}]}],\"/LeetCode\":[{\"text\":\"LeetCode 算法题解\",\"items\":[{\"text\":\"算法笔记\",\"link\":\"/LeetCode/算法笔记\"},{\"text\":\"NO.1 两数之和\",\"link\":\"/LeetCode/NO.1 两数之和\"},{\"text\":\"NO.11 盛最多水的容器\",\"link\":\"/LeetCode/NO.11 盛最多水的容器\"},{\"text\":\"NO.283 移动零\",\"link\":\"/LeetCode/NO.283 移动零\"}]}],\"/viewpoint/\":[{\"text\":\"一些值得记录的观点\",\"items\":[{\"text\":\"大厂的员工还是应该有危机感\",\"link\":\"/viewpoint/大厂的员工还是应该有危机感\"},{\"text\":\"未来如何记住我们的过去？\",\"link\":\"/viewpoint/未来如何记住我们的过去？\"},{\"text\":\"有些人就像 ChatGPT\",\"link\":\"/viewpoint/有些人就像 ChatGPT\"},{\"text\":\"对教育的看法\",\"link\":\"/viewpoint/对教育的看法\"}]}]},\"nav\":[{\"text\":\"Web前端开发\",\"items\":[{\"text\":\"前端应用笔记\",\"link\":\"/notes/WebSocket心跳重连机制\"},{\"text\":\"Three.js的3D世界\",\"link\":\"/three/01.Three.js基础概念\"},{\"text\":\"LeetCode 算法题解\",\"link\":\"/LeetCode/算法笔记\"}]},{\"text\":\"一些值得记录的观点\",\"link\":\"/viewpoint/大厂的员工还是应该有危机感\"}],\"footer\":{\"copyright\":\"Copyright © 2024-present Icarus\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>