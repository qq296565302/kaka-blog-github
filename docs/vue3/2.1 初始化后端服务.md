# 初始化后端服务，使用技术栈：Koa2 + MongoDB

🔴 正在编写...

### Koa2 项目初始化

```powershell
// 1. 确保已安装node.js
$ node -v
// 2. 确保已安装npm或yarn
$ npm -v 或 yarn -v
// 3. 进入空项目文件koa2(项目名)中
$ cd koa2
// 4. 初始化package.json
$ yarn init
// 5. 安装koa
$ yarn add koa -s
```

1. 测试最小系统

1.1 新建 `app.js`

```JavaScript
const Koa = require("koa");
const app = new Koa();
app.use(async (ctx) => {
  ctx.body = "hello koa2";
});
app.listen(3000);
console.log("服务器开启: http://localhost:3000/");
```

1.2 运行系统

```powershell
$ node app.js
```

1.3 浏览器打开

```
http://localhost:3000/
```

> 经过上面最小系统的测试,可以检验我们项目初始化是否有问题,可是我们在接下来的工作中将会减少错误。

2. 安装中间件

-   koa-onerror 错误信息
-   koa-bodyparser 解析 body 中中的 json 请求数据
-   koa-logger 日志
-   koa-cors 跨域
-   koa-static 静态资源
-   koa-router 路由
-   nodemon 热更新
-   debug debug 模式
-   koa2-proxy-middleware 用于代理转的中间件

```
$ yarn add koa-router koa-onerror koa-bodyparser koa-logger koa-cors koa-static nodemon debug koa2-proxy-middleware --save
```

3. 安装数据库(详见下一节)
   略
4. 最终目录结构

-   middelware 中间件
-   controller、控制层 业务代码
-   config 数据库等设置
-   dbhelper sql 语句
-   routes 路由
-   modal 对象层

```
│  app.js
│  package.json
│  REAAME.md
│  yarn.lock
├─app
│  ├─controller
│  │   users.js
│  │
│  └─modal
│      users.js
├─bin
│      www.js
├─config
│      constant.js
│      database.js
│      dbPool.js
├─dbhelper
│      users.js
├─middlewares
│  │  index.js
│  └─middleware
│     message.js
├─routes
│  │  index.js
│  └─route
│      users.js
└─utils
       autoLoadFile.js
```

5. 进行基础配置

5.1 改写`app.js`，注册中间件

```JavaScript
const Koa = require("koa");
const app = new Koa();

const onerror = require("koa-onerror");
const bodyparser = require("koa-bodyparser");
const logger = require("koa-logger");
const router = require("./routes/index");
const cors = require("koa-cors");

// 在使用koa2作为前后端分离的框架，工程当中的静态页面需要请求在其他域名下的接口，由于同源策略的限制，在koa2工程下的静态资源只能通过node后端进行代理请求其他域名下的接口。
const proxy = require('koa2-proxy-middleware');

// 注册error
onerror(app);
// 注册bodyparser
app.use(bodyparser());
// 注册日志
app.use(logger());
// 注册静态资源
app.use(require("koa-static")(__dirname + "/public"));
// 注册跨域
app.use(cors());
// 注册自定义中间件
require('./middlewares/index')(app);
// 注册路由
app.use(router.routes(), router.allowedMethods());

// 配置koa2-proxy-middleware用于代理转的中间件。
const options = {
  targets: {
    '/aktools/(.*)': {
      target: 'http://127.0.0.1:8080/',
      ws: true,
      changeOrigin: true,
      pathRewrite: {
        '^/aktools/': '/api/public/'
      }
    },
  }
}
app.use(proxy(options));

// logger-handling
app.use(async (ctx, next) => {
  const start = new Date();
  await next();
  const ms = new Date() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});
// error-handling
app.on("error", (err, ctx) => {
  console.error("server error", err, ctx);
});

module.exports = app;
```

`koa-onerror`、`koa-bodyparser`、`koa-logger`、`koa-cors`等中间件为`koa`常见中间件，这里不再过多介绍用法。
`koa-router`和`middlewares`做了一些自定义操作，下面会介绍到

5.2 创建入口文件 `bin/www`

```JavaScript
#!/usr/bin/env node
/**
 * Module dependencies.
 */
var app = require('../app');
var debug = require('debug')('demo:server');
var http = require('http');
/**
 * Get port from environment and store in Express.
 */
var port = normalizePort('3000');
/**
 * Create HTTP server.
 */
var server = http.createServer(app.callback());
/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);
/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  var port = parseInt(val, 10);
  if (isNaN(port)) {
    // named pipe
    return val;
  }
  if (port >= 0) {
    // port number
    return port;
  }
  return false;
}
/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }
  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;
  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      //  process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      //  process.exit(1);
      break;
    default:
      throw error;
  }
}
/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

```

5.3 改写`package.json`，添加启动脚本

```JSON
"scripts": {
    "start": "node bin/www",
    "dev": "nodemon bin/www"
}
```

6. 路由配置

-   将路由按模块拆分,方便路由解耦。
-   将注册路由与业务层解耦,方便业务逻辑复用。
-   在路由模块添加路由前缀,使路由更易懂易读。

6.1 实现自动加载文件函数，创建文件`utils/autoLoadFile.js`

```JavaScript
#!/usr/bin/env node
const path = require("path");
const fs = require("fs");
const getPathInfo = (p) => path.parse(p);

/**
 * @description // 递归读取文件，类似于webpack的require.context()
 * @param {String} directory 文件目录
 * @param {Boolean} useSubdirectories 是否查询子目录，默认false
 * @param {array} extList 查询文件后缀，默认 ['.js']
 */
const autoLoadFile = (
  directory,
  useSubdirectories = false,
  extList = [".js"]
) => {
  const filesList = [];
  // 递归读取文件
  function readFileList(directory, useSubdirectories, extList) {
    const files = fs.readdirSync(directory);
    files.forEach((item) => {
      const fullPath = path.join(directory, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && useSubdirectories) {
        readFileList(path.join(directory, item), useSubdirectories, extList);
      } else {
        const info = getPathInfo(fullPath);
        extList.includes(info.ext) && filesList.push(fullPath);
      }
    });
  }
  readFileList(directory, useSubdirectories, extList);
  // 生成需要的对象
  const res = filesList.map((item) => ({
    path: item,
    data: require(item),
    ...getPathInfo(item),
  }));
  return res;
};
module.exports = autoLoadFile;
```

使用示例：

```JavaScript
const context = require("../utils/autoLoadFile");
const fileList = context(path.join(__dirname, "./route"), true);
```

6.2 路由自注册，创建路由自执行文件 `routes/index.js`

```JavaScript
const router = require("koa-router")();
const path = require("path");
const context = require("../utils/autoLoadFile");

/**
 * @param {Array} arr 需要注册路由的文件列表
 */
function importAll(arr) {
  arr.forEach((key) => {
    // 这种方式为嵌套路由
    router.use("/api", key.data.routes(), key.data.allowedMethods());
  });
}
importAll(context(path.join(__dirname, "./route"), false));

module.exports = router;
```

6.3 注册路由

```JavaScript
// app.js
// 引入路由自执行文件
const router = require("./routes/index");
// 注册路由
app.use(router.routes(), router.allowedMethods());
```

6.4 创建路由模块，基础搭建已经好了,创建一个模块试试

```JavaScript
// routes/route/users.js
const router = require("koa-router")();
// 模块路由前缀
router.prefix("/users");
router.post("/", function (ctx, next) {
	ctx.body = "this a users response!";
});
/**
 * 用户登录接口
 * @param {username} 用户名
 * @param {password} 用户密码
 */
router.post("/login", async (ctx) => {
	const request = ctx.request.body;
	const { username, password } = request;
	if(username && password) {
	    ctx.body = {
	        "code":200,
          "msg":"success",
          "data": "登录成功"
	    }
	}
});
module.exports = router;
```

最终路由 path: `localhost:3000/api/users/login`

-   `/api` 为路由前缀
-   `/users` 为模块路由前缀
-   `/login` 具体接口

7. 中间件配置

7.1 中间件自注册，创建自执行文件 `middlewares/index.js`

```JavaScript
const path = require("path");
const context = require("../utils/autoLoadFile");
/**
 * @param {Array} arr 需要注册中间件的文件列表
 */
const install = (app) => {
  context(path.join(__dirname, "./middleware"), false).forEach((key) => {
    app.use(key.data);
  });
};
module.exports = install;
```

7.2 中间件注册

```JavaScript
// app/js
// 注册自定义中间件
require('./middlewares/index')(app);
```

7.3 响应体中间件，创建封装响应体的中间件 `message.js`

```JavaScript
// middlewares/middleware/message.js
module.exports = async (ctx, next) => {
  ctx.res.$success = (data, code = 200) => {
    const _data = {
      code,
    };
    if (typeof data === "object") {
      _data.msg = "success";
      _data.data = data;
    } else {
      _data.msg = data;
    }
    ctx.body = _data;
  };
  ctx.res.$error = (err, code = 500) => {
    const _data = {
      code,
    };
    if (typeof err === "object") {
      _data.msg = "error";
      _data.data = JSON.stringify(err);
    } else {
      _data.msg = err;
    }
    ctx.body = _data;
  };
  await next();
};
```

7.4 响应体中间件使用示例

```JavaScript
router.post('/login', async (ctx) => {
  const request = ctx.request.body;
  const { username, password } = request;
  if (username&&password) {
    ctx.res.$success('登录成功');
  } else {
    ctx.res.$error("请求失败", 403);
  }
})
```

7.5 响应体中间件结果

```JavaScript
// 成功
{
    "code":200,
    "msg":"success",
    "data":"登录成功"
}

// 失败
{
    "code":403,
    "msg":"error",
    "data":"请求失败"
}
```

### MongoDB 安装和配置
