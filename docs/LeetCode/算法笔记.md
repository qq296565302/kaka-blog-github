### 🔴 正在编写...

## 一、初识算法

当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖于基本逻辑，这些逻辑在我们的日常生活中处处可见。

## 1.1 数据结构定义

数据结构(data structure)是计算机中组织和存储数据的方式，具有以下设计目标：

-   空间占用尽量 <mark>减少</mark> ，节省计算机内存。
-   数据操作尽可能 <mark>快速</mark> ，涵盖数据访问、添加、删除、更新等。
-   提供 <mark>简洁</mark> 的数据表示和逻辑信息，以便使得算法高效运行。

**数据结构设计是一个充满权衡的过程。**

如果想要在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。

-   链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。
-   图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。

## 1.2 数据结构与算法的关系

算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。数据结构与算法高度相关、紧密结合，具体表现以下三个方面：

-   **数据结构是算法的基石**。数据结构为算法提供了结构化存储的数据，以及用于操作数据的方法。
-   **算法是数据结构发挥作用的舞台**。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
-   算法通常可以基于不同的数据结构进行实现，并往往**有对应最优的数据结构**，但最终执行效率可能相差很大。

> 值得说明的是，数据结构与算法是独立于编程语言的。在实际讨论时，我们通常会将“数据结构与算法”简称为“算法”。比如众所周知的 `LeetCode` 算法题目，实际上同时考察了数据结构和算法两方面的知识。

## 二、复杂度分析

## 2.1 算法效率评估

在算法设计中，我们先后追求以下两个层面的目标。

1. 找到问题解法：算法需要在规定的输入范围内，可靠地求得问题的正确解。
2. 寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。

也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度：

-   时间效率：算法 <mark>运行速度</mark> 的快慢。
-   空间效率：算法 <mark>占用内存空间</mark> 的大小。

简而言之，我们的目标是**设计既快又省的数据结构与算法**。而有效地评估算法效率至关重要，因为只有这样我们才能将各种算法进行对比，从而指导算法设计与优化过程。效率评估方法主要分为两种：**实际测试、理论估算**。

### 2.1.1 实际测试

忽略不计，存在难以排除测试环境的干扰因素，同时展开完整测试非常耗费资源。

### 2.1.2 理论估算

由于实际测试具有较大的局限性，我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为**渐近复杂度分析**，简称复杂度分析。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。

## 2.2 迭代与递归

在数据结构与算法中，重复执行某个任务是很常见的，其与算法的复杂度密切相关。而要重复执行某个任务，我们通常会选用两种基本的程序结构：迭代和递归。

### 2.2.1 迭代

**迭代**是一种重复执行某个任务的控制结构。在迭代中，程序会**在满足一定的条件下重复执行某段代码**，直到这个条件不再满足。

1. `for`循环
   `for` 循环是最常见的迭代形式之一，适合预先知道迭代次数时使用。
   以下函数基于 `for` 循环实现了求和 1 + 2 + ⋯ + 𝑛 ，求和结果使用变量 `res` 记录。

```JavaScript
/* for 循环 */
function forLoop(n) {
  let res = 0;
  // 循环求和 1, 2, ..., n-1, n
  for (let i = 1; i <= n; i++) {
    res += i;
  }
  return res;
}
```

此求和函数的操作数量与输入数据大小 `𝑛` 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。

2. `while`循环
   与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在`while` 循环中，程序每轮都会先检查条件，如果条件为真则继续执行，否则就结束循环。下面，我们用 `while` 循环来实现求和 1 + 2 + ⋯ + 𝑛 。

```JavaScript
/* while 循环 */
function whileLoop(n) {
  let res = 0;
  let i = 1; // 初始化条件变量
  // 循环求和 1, 2, ..., n-1, n
  while (i <= n) {
    res += i;
    i++; // 更新条件变量
  }
  return res;
}
```

在 `while` 循环中，由于初始化和更新条件变量的步骤是独立在循环结构之外的，因此它**比 `for` 循环的自由度更高**。
总的来说，`for` 循环的代码更加紧凑，`while` 循环更加灵活，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。

3. 嵌套循环

我们可以在一个循环结构内嵌套另一个循环结构，以 `for` 循环为例：

```JavaScript
/* 双层 for 循环 */
function nestedForLoop(n) {
  let res = '';
  // 循环 i = 1, 2, ..., n-1, n
  for (let i = 1; i <= n; i++) {
    // 循环 j = 1, 2, ..., n-1, n
    for (let j = 1; j <= n; j++) {
      res += `(${i}, ${j}), `;
    }
  }
  return res;
}
```

在这种情况下，函数的操作数量与 `n²` 成正比，或者说算法运行时间和输入数据大小 `𝑛` 成“平方关系”。我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”、“四次方关系”、以此类推。

### 2.2.1 递归

**递归**是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

而从实现的角度看，递归代码主要包含三个要素。

1. **终止条件**：用于决定什么时候由“递”转“归”。
2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。

观察以下代码，我们只需调用函数 `recur(n)` ，就可以完成 `1 + 2 + ⋯ + 𝑛` 的计算：

```JavaScript
/* 递归 */
function recur(n) {
  // 终止条件
  if (n === 1) return 1;
  // 递：递归调用
  const res = recur(n - 1);
  // 归：返回结果
  return n + res;
}
```

虽然从计算角度看，迭代与递归可以得到相同的结果，但它们**代表了两种完全不同的思考和解决问题的范式**。

-   迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。
-   递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

以上述的求和函数为例，设问题 `𝑓(𝑛) = 1 + 2 + ⋯ + 𝑛 `。

-   迭代：在循环中模拟求和过程，从 `1` 遍历到 `𝑛` ，每轮执行求和操作，即可求得 `𝑓(𝑛)` 。
-   递归：将问题分解为子问题 `𝑓(𝑛) = 𝑛+𝑓(𝑛−1)` ，不断（递归地）分解下去，直至基本情况 `𝑓(0) = 0`时终止。
